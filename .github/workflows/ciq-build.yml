name: CIQ Build

on:
  workflow_dispatch:
  push:
    paths:
      - "source/**"
      - "resources/**"
      - "manifest.xml"
      - "tools/**"
      - ".github/workflows/ciq-build.yml"
  pull_request:
    paths:
      - "source/**"
      - "resources/**"
      - "manifest.xml"
      - "tools/**"

# Permissions minimales pour la s√©curit√©
permissions:
  contents: read
  actions: read
  checks: write

env:
  # Variables d'environnement globales
  JAVA_VERSION: "17"
  MIN_SDK_VERSION: "3.1.0"
  OUTPUT_NAME: "OWSwim_VA4"
  SUPPORTED_DEVICES: "vivoactive4"
  COMPILER_VERSION: "8.1.1"
  BUILD_MEMORY: "-Xms1g -Xmx2g"

jobs:
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate required files
        run: |
          set -euo pipefail
          
          # V√©rifier les fichiers requis
          required_files=(
            "manifest.xml"
            "tools/monkeybrains-${COMPILER_VERSION}.jar"
            "tools/api.db"
            "tools/api.mir"
            "tools/compilerInfo.xml"
          )
          
          missing_files=()
          for file in "${required_files[@]}"; do
            if [[ ! -f "$file" ]]; then
              missing_files+=("$file")
            fi
          done
          
          if [[ ${#missing_files[@]} -gt 0 ]]; then
            echo "‚ùå Fichiers manquants:"
            printf "  - %s\n" "${missing_files[@]}"
            exit 1
          fi
          
          echo "‚úÖ Tous les fichiers requis sont pr√©sents"

      - name: Validate manifest.xml syntax
        run: |
          set -euo pipefail
          
          # Validation XML avec Python
          python3 -c "
          import xml.etree.ElementTree as ET
          import sys
          try:
              ET.parse('manifest.xml')
              print('‚úÖ manifest.xml est valide')
          except ET.ParseError as e:
              print(f'‚ùå manifest.xml contient des erreurs de syntaxe XML: {e}')
              sys.exit(1)
          except Exception as e:
              print(f'‚ùå Erreur lors de la validation: {e}')
              sys.exit(1)
          "

  build:
    name: Build Connect IQ Application
    runs-on: ubuntu-latest
    needs: validate
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ env.JAVA_VERSION }}

      - name: Cache Java installation
        uses: actions/cache@v4
        with:
          path: ~/.java
          key: java-${{ env.JAVA_VERSION }}-${{ runner.os }}

      - name: Cache Connect IQ tools
        uses: actions/cache@v4
        with:
          path: tools/
          key: ciq-tools-${{ env.COMPILER_VERSION }}-${{ hashFiles('tools/*.jar', 'tools/*.db', 'tools/*.mir') }}
          restore-keys: |
            ciq-tools-${{ env.COMPILER_VERSION }}-
            ciq-tools-

      - name: Normalize file encodings
        run: |
          set -euo pipefail
          shopt -s globstar nullglob
          
          echo "üîß Normalisation des encodages..."
          files=(manifest.xml resources/**/*.xml source/**/*.mc)
          normalized_count=0
          
          for f in "${files[@]}"; do
            [[ -f "$f" ]] || continue
            
            # Supprimer le BOM UTF-8 si pr√©sent et normaliser
            if awk 'NR==1{sub(/^\xef\xbb\xbf/,"")}1' "$f" > "$f.tmp"; then
              if ! cmp -s "$f" "$f.tmp"; then
                mv "$f.tmp" "$f"
                ((normalized_count++))
                echo "  ‚úì Normalis√©: $f"
              else
                rm "$f.tmp"
              fi
            else
              echo "  ‚ö†Ô∏è  Erreur lors de la normalisation: $f"
            fi
          done
          
          echo "üìä $normalized_count fichier(s) normalis√©(s)"

      - name: Generate monkey.jungle configuration
        run: |
          set -euo pipefail
          
          echo "üêí G√©n√©ration de monkey.jungle..."
          cat > monkey.jungle << 'EOF'
          # Configuration g√©n√©r√©e automatiquement
          project.manifest = manifest.xml
          base.sourcePath = source
          base.resourcePath = resources
          EOF
          
          echo "‚úÖ monkey.jungle cr√©√©:"
          cat monkey.jungle

      - name: Create build directory
        run: |
          mkdir -p bin
          echo "üìÅ R√©pertoire bin cr√©√©"

      - name: Setup developer key
        env:
          CIQ_DEV_KEY_B64: ${{ secrets.CIQ_DEV_KEY_B64 }}
        run: |
          set -euo pipefail
          
          if [[ -z "${CIQ_DEV_KEY_B64:-}" ]]; then
            echo "‚ùå Secret CIQ_DEV_KEY_B64 manquant"
            echo "Veuillez ajouter votre cl√© de d√©veloppeur Connect IQ encod√©e en base64"
            exit 1
          fi
          
          echo "üîë Configuration de la cl√© de d√©veloppeur..."
          echo "$CIQ_DEV_KEY_B64" | base64 -d > developer_key
          chmod 600 developer_key
          
          if [[ ! -s developer_key ]]; then
            echo "‚ùå La cl√© de d√©veloppeur est vide apr√®s d√©codage"
            exit 1
          fi
          
          echo "‚úÖ Cl√© de d√©veloppeur configur√©e"

      - name: Configure manifest for target devices
        run: |
          set -euo pipefail
          
          echo "‚öôÔ∏è  Configuration du manifest pour ${SUPPORTED_DEVICES}..."
          
          # Backup du manifest original
          cp manifest.xml manifest.xml.backup
          
          # Mise √† jour de la version SDK minimale
          if ! sed -i "s/minSdkVersion=\"[^\"]*\"/minSdkVersion=\"${MIN_SDK_VERSION}\"/" manifest.xml; then
            echo "‚ùå Erreur lors de la mise √† jour de minSdkVersion"
            exit 1
          fi
          
          # Mise √† jour des produits cibles (conversion de la liste en XML)
          devices_xml=""
          IFS=',' read -ra DEVICES <<< "$SUPPORTED_DEVICES"
          for device in "${DEVICES[@]}"; do
            devices_xml+="<iq:product id=\"$device\"/>"
          done
          
          if ! perl -0777 -pe "s|<iq:products>.*?</iq:products>|<iq:products>$devices_xml</iq:products>|s" -i manifest.xml; then
            echo "‚ùå Erreur lors de la mise √† jour des produits"
            exit 1
          fi
          
          # V√©rification des modifications
          if grep -q 'vivoactive4' manifest.xml; then
            echo "‚úÖ Manifest configur√© pour ${SUPPORTED_DEVICES}"
            echo "üìã Produits cibles:"
            grep -o 'vivoactive4s\?' manifest.xml | sort -u | sed 's/^/  - /'
          else
            echo "‚ö†Ô∏è  Les produits cibles n'ont pas √©t√© trouv√©s dans le manifest"
          fi

      - name: Build Connect IQ application
        working-directory: tools
        run: |
          set -euxo pipefail
          
          echo "üî® Compilation de l'application Connect IQ..."
          
          # Variables pour les chemins
          JAR="$PWD/monkeybrains-${COMPILER_VERSION}.jar"
          JUNGLE="$GITHUB_WORKSPACE/monkey.jungle"
          OUT="$GITHUB_WORKSPACE/bin/${OUTPUT_NAME}.iq"
          KEY="$GITHUB_WORKSPACE/developer_key"
          MANIFEST="$GITHUB_WORKSPACE/manifest.xml"
          
          # V√©rification finale des fichiers requis
          required_files=("$JAR" "$PWD/api.db" "$PWD/api.mir" "$PWD/compilerInfo.xml" "$KEY" "$JUNGLE" "$MANIFEST")
          for file in "${required_files[@]}"; do
            if [[ ! -s "$file" ]]; then
              echo "‚ùå Fichier requis manquant ou vide: $file"
              exit 1
            fi
          done
          
          echo "üîç Diagnostic des fichiers:"
          echo "üìè JAR: $(stat -c%s "$JAR") bytes"
          echo "üìè Manifest: $(stat -c%s "$MANIFEST") bytes"
          echo "üìè Jungle: $(stat -c%s "$JUNGLE") bytes"
          echo "üìè Key: $(stat -c%s "$KEY") bytes"
          echo ""
          
          # Compilation DIRECTE avec jungle UNIQUEMENT (pas de -m)
          echo "üöÄ Compilation avec jungle file..."
          
          if ! java $BUILD_MEMORY -Dfile.encoding=UTF-8 -jar "$JAR" \
            -a "$PWD/api.db" \
            -b "$PWD/api.mir" \
            -f "$JUNGLE" \
            -o "$OUT" \
            -y "$KEY" \
            -e -w; then
            
            echo "‚ùå √âchec de compilation"
            echo "üìã Informations de d√©bogage:"
            echo "  - JAR: $JAR ($(du -h "$JAR" | cut -f1))"
            echo "  - Manifest: $MANIFEST"
            echo "  - Jungle: $JUNGLE"
            echo "  - Key: pr√©sente ($(stat -c%s "$KEY") bytes)"
            
            echo "üìÑ Contenu de monkey.jungle:"
            cat "$JUNGLE"
            
            echo "üìÑ D√©but du manifest.xml:"
            head -n 20 "$MANIFEST"
            
            exit 1
          fi
          
          # V√©rification du fichier de sortie
          if [[ ! -f "$OUT" ]]; then
            echo "‚ùå Le fichier .iq n'a pas √©t√© g√©n√©r√©"
            exit 1
          fi
          
          file_size=$(stat -c%s "$OUT")
          echo "‚úÖ Application compil√©e avec succ√®s!"
          echo "üì¶ Fichier g√©n√©r√©: $OUT ($(numfmt --to=iec-i --suffix=B $file_size))"

      - name: Validate generated .iq file
        run: |
          set -euo pipefail
          
          iq_file="bin/${OUTPUT_NAME}.iq"
          
          if [[ ! -f "$iq_file" ]]; then
            echo "‚ùå Fichier .iq non trouv√©: $iq_file"
            exit 1
          fi
          
          # V√©rifier que c'est un fichier ZIP valide (les .iq sont des archives ZIP)
          if ! file "$iq_file" | grep -q -i zip; then
            echo "‚ùå Le fichier .iq ne semble pas √™tre une archive valide"
            file "$iq_file"
            exit 1
          fi
          
          # Test de structure de l'archive
          echo "üîç Test de la structure .iq..."
          if ! unzip -t "$iq_file" >/dev/null 2>&1; then
            echo "‚ùå Archive .iq corrompue"
            exit 1
          fi
          
          # V√©rifier le contenu attendu
          expected_files=(manifest.xml)
          missing_in_archive=()
          
          for expected_file in "${expected_files[@]}"; do
            if ! unzip -l "$iq_file" | grep -q "$expected_file"; then
              missing_in_archive+=("$expected_file")
            fi
          done
          
          if [[ ${#missing_in_archive[@]} -gt 0 ]]; then
            echo "‚ö†Ô∏è  Fichiers manquants dans l'archive:"
            printf "  - %s\n" "${missing_in_archive[@]}"
          fi
          
          # Informations finales
          file_size=$(stat -c%s "$iq_file")
          
          if (( file_size < 1024 )); then
            echo "‚ùå Le fichier .iq semble trop petit ($file_size bytes)"
            exit 1
          fi
          
          echo "‚úÖ Fichier .iq valid√©:"
          echo "  - Taille: $(numfmt --to=iec-i --suffix=B $file_size)"
          echo "  - Type: $(file -b "$iq_file")"
          echo "  - Contenu: $(unzip -l "$iq_file" | wc -l) fichiers"

      - name: Cleanup developer key
        if: always()
        run: |
          if [[ -f developer_key ]]; then
            shred -vfz -n 3 developer_key || rm -f developer_key
            echo "üîí Cl√© de d√©veloppeur nettoy√©e de mani√®re s√©curis√©e"
          fi

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.OUTPUT_NAME }}
          path: bin/*.iq
          retention-days: 30
          if-no-files-found: error

      - name: Upload build logs (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ github.run_number }}
          path: |
            manifest.xml.backup
            monkey.jungle
            bin/
          retention-days: 7
          if-no-files-found: ignore
